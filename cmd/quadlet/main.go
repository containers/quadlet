package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/containers/quadlet/pkg/quadlet"
	"github.com/containers/quadlet/pkg/systemdparser"
)

var (
	verboseFlag bool // True if -v passed
	versionFlag bool // True if --version passed
	isUser      bool // True if run as quadlet-user-generator executable
)

var (
	// data saved between logToKmsg calls
	noKmsg   bool     = false
	kmsgFile *os.File = nil
)

func logToKmsg(s string) bool {
	if noKmsg {
		return false
	}

	if kmsgFile == nil {
		f, err := os.OpenFile("/dev/kmsg", os.O_WRONLY, 0644)
		if err != nil {
			noKmsg = true
			return false
		}
		kmsgFile = f
	}

	if _, err := kmsgFile.Write([]byte(s)); err != nil {
		kmsgFile.Close()
		kmsgFile = nil
		return false
	}

	return true
}

func Log(format string, a ...any) {
	s := fmt.Sprintf(format, a...)
	line := fmt.Sprintf("quadlet-generator[%d]: %s", os.Getpid(), s)

	if !logToKmsg(line) {
		// If we can't log, print to stderr
		fmt.Fprintf(os.Stderr, "%s\n", line)
		os.Stderr.Sync()
	}
}

var debugEnabled bool = false

func enableDebug() {
	debugEnabled = true
}

func Debug(format string, a ...any) {
	if debugEnabled {
		Log(format, a...)
	}
}

func getUnitDirs(user bool) []string {

	unitDirsEnv := os.Getenv("QUADLET_UNIT_DIRS")
	if len(unitDirsEnv) > 0 {
		return strings.Split(unitDirsEnv, ":")
	}

	dirs := make([]string, 0)
	if user {
		if configDir, err := os.UserConfigDir(); err == nil {
			dirs = append(dirs, path.Join(configDir, "containers/systemd"))
		}
	} else {
		dirs = append(dirs, quadlet.UnitDirAdmin)
		dirs = append(dirs, quadlet.UnitDirDistro)
	}
	return dirs
}

func loadUnitsFromDir(sourcePath string, units map[string]*systemdparser.UnitFile) {
	files, err := os.ReadDir(sourcePath)
	if err != nil {
		if !errors.Is(err, os.ErrNotExist) {
			Log("Can't read \"%s\": %s", sourcePath, err)
		}
		return
	}

	for _, file := range files {
		name := file.Name()
		if units[name] == nil &&
			(strings.HasSuffix(name, ".container") ||
				strings.HasSuffix(name, ".volume")) {
			path := path.Join(sourcePath, name)

			Debug("Loading source unit file %s", path)

			if f, err := systemdparser.ParseUnitFile(path); err != nil {
				Log("Error loading '%s', ignoring: %s", path, err)
			} else {
				units[name] = f
			}
		}
	}
}

func generateServiceFile(outputPath string, service *systemdparser.UnitFile) error {
	Debug("writing '%s'", service.Path)

	service.PrependComment("",
		"Automatically generated by quadlet-generator",
		"")

	f, err := os.Create(service.Path)
	if err != nil {
		return err
	}

	defer f.Close()

	err = service.Write(f)
	if err != nil {
		return err
	}

	err = f.Sync()
	if err != nil {
		return err
	}

	return nil
}

func enableServiceFile(outputPath string, service *systemdparser.UnitFile) {
	symlinks := make([]string, 0)

	aliases := service.LookupAllStrv(quadlet.InstallGroup, "Alias")
	for _, alias := range aliases {
		symlinks = append(symlinks, filepath.Clean(alias))
	}

	wantedBy := service.LookupAllStrv(quadlet.InstallGroup, "WantedBy")
	for _, wantedByUnit := range wantedBy {
		// Only allow filenames, not paths
		if !strings.Contains(wantedByUnit, "/") {
			symlinks = append(symlinks, fmt.Sprintf("%s.wants/%s", wantedByUnit, service.Filename))
		}
	}

	requiredBy := service.LookupAllStrv(quadlet.InstallGroup, "RequiredBy")
	for _, requiredByUnit := range requiredBy {
		// Only allow filenames, not paths
		if !strings.Contains(requiredByUnit, "/") {
			symlinks = append(symlinks, fmt.Sprintf("%s.requires/%s", requiredByUnit, service.Filename))
		}
	}

	for _, symlinkRel := range symlinks {
		target, err := filepath.Rel(path.Dir(symlinkRel), service.Filename)
		if err != nil {
			Log("Can't create symlink %s: %s", symlinkRel, err)
			continue
		}
		symlinkPath := path.Join(outputPath, symlinkRel)

		symlinkDir := path.Dir(symlinkPath)
		err = os.MkdirAll(symlinkDir, os.ModePerm)
		if err != nil {
			Log("Can't create dir %s: %s", symlinkDir, err)
			continue
		}

		Debug("Creating symlink %s -> %s", symlinkPath, target)
		_ = os.Remove(symlinkPath) // overwrite existing symlinks
		err = os.Symlink(target, symlinkPath)
		if err != nil {
			Log("Failed creating symlink %s: %s", symlinkPath, err)
		}
	}
}

func main() {
	prgname := path.Base(os.Args[0])
	isUser = strings.Contains(prgname, "user")

	flag.Parse()

	if verboseFlag {
		enableDebug()
	}

	if versionFlag {
		fmt.Println("quadlet-ng 0.0.1")
		os.Exit(0)
	}

	if flag.NArg() < 1 {
		Log("Missing output directory argument")
		os.Exit(1)
	}

	outputPath := flag.Arg(0)

	Debug("Starting quadlet-generator, output to: %s", outputPath)

	sourcePaths := getUnitDirs(isUser)

	units := make(map[string]*systemdparser.UnitFile)
	for _, d := range sourcePaths {
		loadUnitsFromDir(d, units)
	}

	err := os.MkdirAll(outputPath, os.ModePerm)
	if err != nil {
		Log("Can't create dir %s: %s", outputPath, err)
		os.Exit(1)
	}

	for name, unit := range units {
		var service *systemdparser.UnitFile
		var err error

		if strings.HasSuffix(name, ".container") {
			service, err = quadlet.ConvertContainer(unit, isUser)
		} else if strings.HasSuffix(name, ".volume") {
			service, err = quadlet.ConvertVolume(unit, name)
		} else {
			Log("Unsupported file type '%s'", name)
			continue
		}

		if err != nil {
			Log("Error converting '%s', ignoring: %s", name, err)
		} else {
			service.Path = path.Join(outputPath, service.Filename)

			if err := generateServiceFile(outputPath, service); err != nil {
				Log("Error writing '%s'o: %s", service.Path, err)
			}
			enableServiceFile(outputPath, service)
		}
	}

}

func init() {
	flag.BoolVar(&verboseFlag, "v", false, "Print debug information")
	flag.BoolVar(&versionFlag, "version", false, "Print version information and exit")
}
